---
id: project-setup
title: Go SDK developer's guide - Project setup
sidebar_label: Project setup
sidebar_position: 2
description: The project setup section of the Temporal Go SDK Developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application in Go – that is, all the relevant steps to start a Workflow Execution that executes an Activity.
slug: /dev-guide/go/project-setup
toc_max_heading_level: 4
keywords:
- activity
- code sample
- dev guide
- developer guide
- go sdk
- introduction
- project setup
- temporal cli
- temporal client
- test framework
- testing
- worker
- workflow
tags:
- activity
- code-sample
- dev-guide
- developer-guide
- go-sdk
- introduction
- project-setup
- temporal-cli
- temporal-client
- test-framework
- testing
- worker
- workflow
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::competency Construct a new Temporal Application project

This section of the Temporal Go SDK developer's guide covers the minimum set of concepts and implementation details needed to build and run a Temporal Application using Go.

By the end of this section you will know how to construct a new Temporal Application project.

:::

- [How to download and install the Temporal CLI](#install-cli)
- [Which development Cluster you should choose](#choose-dev-cluster)
- How to create a new Namespace in your development Cluster
  - [Local dev server](#local-dev-server)
  - [Temporal Cloud](#temporal-cloud)
- [Boilerplate application code and file structure best practices](#boilerplate-project)
- How to run your Worker
  - [Local dev server Worker](#dev-server-worker)
  - Temporal Cloud Worker
  - Self-hosted Worker
- How to start your Workflow using the CLI
  - [Start on local dev server](#local-dev-server)
  - [Start on Temporal Cloud](#temporal-cloud)
  - [Start on Self-hosted](#self-hosted)
- [How to add a testing framework and tests to your application](#test-framework)

## Install the Temporal CLI {#install-cli}

**How to download and install the Temporal CLI?**

The Temporal CLI is available on the MacOs, Windows, and Linux.

### MacOS

**How to install the Temporal CLI on Mac OS?**

Choose one of the following install methods to install the Temporal CLI on MacOS:

**Install the Temporal CLI with Homebrew.**

```bash
brew install temporal
```

**Install the Temporal CLI with cURL**

```bash
curl -sSf https://temporal.download/cli.sh | sh
```

**Install the Temporal CLI from CDN.**

1. Select the platform and architecture needed.

- Download for Darwin amd64 → https://temporal.download/cli/archive/latest?platform=darwin&arch=amd64
- Download for Darwin arm64 → https://temporal.download/cli/archive/latest?platform=darwin&arch=arm64

2. Extract the downloaded archive.

3. Add the `temporal` binary to your PATH.

### Linux

**How to install the Temporal CLI on Linux?**

Choose one of the following install methods to install the Temporal CLI on Linux:

**Install the Temporal CLI with cURL.**

```bash
curl -sSf https://temporal.download/cli.sh | sh
```

**Install the Temporal CLI from CDN.**

1. Select the platform and architecture needed.

- Download for Linux amd64 → https://temporal.download/cli/archive/latest?platform=linux&arch=amd64
- Download for Linux arm64 → https://temporal.download/cli/archive/latest?platform=linux&arch=arm64

2. Extract the downloaded archive.

3. Add the `temporal` binary to your PATH.

### Windows

**How to install the Temporal CLI on Windows?**

Follow these instructions to install the Temporal CLI on Windows:

**Install the Temporal CLI from CDN.**

1. Select the platform and architecture needed and download the binary.

- Download for Windows amd64 → https://temporal.download/cli/archive/latest?platform=windows&arch=amd64
- Download for Windows arm64 → https://temporal.download/cli/archive/latest?platform=windows&arch=arm64

2. Extract the downloaded archive.

3. Add the `temporal.exe` binary to your PATH.

## Choose a development Cluster {#choose-dev-cluster}

**Which development Cluster should you choose?**

We recommend choosing a development environment based on your requirements.

The source code for the Temporal Server (the orchestrating component of the Temporal Cluster) has an MIT open source license. So, in theory, anyone can take the Temporal Server code and run their Temporal Platform in any number of creative ways.

However, for most developers we recommend starting by choosing one of the following:

- Local development server
- Temporal Cloud
- Self-hosted

:::info Temporal does not directly run your code

Keep in mind that in every scenario, the “Temporal Platform” does not host and run your Workers (application code). It is up to you, the developer, to host your Application code. The Temporal Platform ensures that properly written code durably executes in the face of platform level failures.

:::

### Local dev server

**When to use a local development server?**

We recommend using the local development server if you are new to Temporal, or want to start something from scratch and don’t have a Self-hosted environment ready or want to pay for a Temporal Cloud Account.

The Temporal CLI comes bundled with a development server and it provides a fast way to start running Temporal Applications.

However, the local development server does not emit any metrics, and if you are eager to to set up Cluster level metrics for performance tuning, we recommend using a Self-hosted Cluster or Temporal Cloud.

#### Start the dev server

**How to start a local development server?**

If you have successfully installed the Temporal CLI, open a new terminal and run the following command:

```bash
temporal server start-dev
```

This command automatically starts up the Temporal Web UI, creates a default Namespace, and creates an in-memory database.

The Temporal Web UI serves to [`http://localhost:8233`](http://localhost:8233/).

For more command details and options, see the [CLI reference](/cli/server#start-dev)

#### Create a custom Namespace

**How to create a new Namespace on the development server?**

The development server does automatically create a default Namespace (named "default") when it starts up.
However, we will create a custom one for our application.
Since this is something we recommend at a production level, we recommend practicing it with the development server.

Use the `temporal operator namespace create` command using the Temporal CLI to create a new Namespace on the development server.

```bash
temporal operator namespace create backgroundcheck_namespace
```

For command details and options, see the [CLI reference](/cli/operator#create).

### Temporal Cloud

**When to use Temporal Cloud?**

If you do not have a Temporal Cloud Account, you can request one using the link on the [getting started page](https://docs.temporal.io/cloud/get-started).

We recommend starting off with Temporal Cloud if you already have a production use case, or need to move a scalable proof of concept into production.

In other words, Temporal Cloud is perfect if you are ready to run at scale and don’t want the overhead of managing your own Self-hosted Cluster.

Follow the [Create a new Temporal Cloud Namespace guide](/cloud/namespaces#create-a-namespace) to create a new Namespace in Temporal Cloud.

:::info Safely store your certificate and private key

Store your certificate and private key you generated for your Namespace as files or env variables in your project.
You will need access to your cert and key to run your Workers and start Workflows.

For Cloud certificate requirements and details check out the [Cloud certificate management guide](/cloud/certificates#).

:::

### Self-hosted

We recommend using a Self-Hosted environment if you are starting something new and need to scale with production-level features, but don’t yet need or want to pay for Temporal Cloud.

For example, running a Self-Hosted Cluster enables you to try different databases, view Cluster metrics, use custom [Search Attributes](/visibility#search-attribute), and even play with the [Archival](/clusters#archival) feature.

It's completely possible to run a production level Self-hosted Cluster.
However, for the purposes of this guide, we show how to use a Self-hosted environment that runs completely out of Docker.
We acknowledge that it takes a fair amount of experience to elevate from a Self-hosted environment in Docker to something that can run at an enterprise production scale.
The Self-hosted information in this guide should help you make more informed decisions.

To follow along with Self-hosted parts of this guide, install the following:

- [Docker](https://docs.docker.com/engine/install)
- [Docker Compose](https://docs.docker.com/compose/install).

Then, clone the [temporalio/docker-compose](https://github.com/temporalio/docker-compose.git) repository.

Change directory into the root of the project.

Run the `docker-compose up` command.

```shell
git clone https://github.com/temporalio/docker-compose.git
cd  docker-compose
docker-compose up
```

Create a command alias for the Temporal CLI:

```shell
alias temporal_docker="docker exec temporal-admin-tools temporal"
```

Create a new Namespace.

```shell
temporal_docker operator namespace create backgroundcheck_namespace
```

## Boilerplate Temporal Application project code {#boilerplate-project}

**What is the minimum code I need to create a boilerplate Temporal Application?**

Let’s start out with a single Activity Workflow and a Worker and add a testing framework.

### Project structure

You can organize Temporal Application code to suit various needs in a way that aligns with the idiomatic style of the language you are working in.
This includes structuring your files according to your organization's best practices.

However, there are some general ways to think about organizing code.

The best practice is to group Workflows together, Activities together, and separate your Worker process into a standalone file.
Often this happens respectively per use case, business process, or domain.

For mono-repo style organizational techniques, consider a designated Workflow directory for each use case and place each Workflow in its own file, but also maintain a dedicated place for shared Activities.

For example your project structure could look like this:

```text
/monorepo
    /shared_activities
        | payment.go
        | send_email.go
    /backgroundcheck
        /workflows
            | backgroundcheck.go
        /activities
            | ssntrace.go
        /worker
            | main.go
    /loanapplication
        /workflows
            | loanapplication.go
        /activities
            | creditcheck.go
        /worker
            | main.go
```

If you are following along with this guide, your project will look like this:

```text
/backgroundcheck
    /workflows
        | backgroundcheck.go
    /activities
        | ssntrace.go
    /worker
        | main.go
```

### Initialize Go project dependency framework

If you have created a similar project structure as noted above, run `go mod init` to create a new go module for this project.

```bash
mkdir backgroundcheck
cd backgroundcheck
go mod init
```

Module name will be something like `<repo>/backgroundcheck` .

### Boilerplate Workflow code {#workflow-code}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheck_dacx.go. -->

In the Temporal Go SDK programming model, a [Workflow Definition](/workflows#workflow-definition) is an exportable function.
The `BackgroundCheck` function below is an example of a basic Workflow Definition.

:::copycode Copy this code!

This code is synced from a working and tested example application.
[View source](https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheck_dacx.go)

:::

```go
package backgroundcheck_boilerplate

import (
	"time"

	"go.temporal.io/sdk/workflow"
)


// BackgroundCheck is your custom Workflow Definition.
func BackgroundCheck(ctx workflow.Context, param string) (string, error) {
	// Define the Activity Execution options
	// StartToCloseTimeout or ScheduleToCloseTimeout must be set
	activityOptions := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Second,
	}
	ctx = workflow.WithActivityOptions(ctx, activityOptions)
	// Execute the Activity synchronously (wait for the result before proceeding)
	var ssnTraceResult string
	err := workflow.ExecuteActivity(ctx, SSNTraceActivity, param).Get(ctx, &ssnTraceResult)
	if err != nil {
		return "", err
	}
	// Make the results of the Workflow available
	return ssnTraceResult, nil
}
```

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheck_dacx.go. -->

The first parameter of a Go-based Workflow Definition must be of the [`workflow.Context`](https://pkg.go.dev/go.temporal.io/sdk/workflow#Context) type.
It is used by the Temporal Go SDK to pass around Workflow Execution context, and virtually all the Go SDK APIs that are callable from the Workflow require it.
It is acquired from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/sdk/workflow) package.

The `workflow.Context` entity operates similarly to the standard `context.Context` entity provided by Go.
The only difference between `workflow.Context` and `context.Context` is that the `Done()` function, provided by `workflow.Context`, returns `workflow.Channel` instead of the standard Go `chan`.

Additional parameters can be passed to the Workflow when it is invoked.
A Workflow Definition may support multiple custom parameters, or none.
All Workflow Definition parameters must be serializable and can't be channels, functions, variadic, or unsafe pointers.

To spawn an [Activity Execution](/activities#activity-execution), call [`ExecuteActivity()`](https://pkg.go.dev/go.temporal.io/workflow#ExecuteActivity) inside your Workflow Definition.
The API is available from the [`go.temporal.io/sdk/workflow`](https://pkg.go.dev/go.temporal.io/workflow) package.
The `ExecuteActivity()` API call requires an instance of `workflow.Context`, the Activity function name, and any variables to be passed to the Activity Execution.

A Go-based Workflow Definition can return either just an `error` or a `customValue, error` combination.
We get into the best practices around Workflow params and returns in the one of the next sections.

In regards to code organization, we recommend organizing Workflow code together with other Workflow code.
For example, in a small project like this, it is still a best practice to have a dedicated file for each Workflow.

### Boilerplate Activity code {#activity-code}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/ssntraceactivity_dacx.go. -->

In the Temporal Go SDK programming model, an Activity is an exportable function or a `struct` method.
Below is an example of an Activity defined as a function.

:::copycode Copy this code!

This code is synced from a working and tested example application.
[View source](https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/ssntraceactivity_dacx.go)

:::

```go
package backgroundcheck_boilerplate

import (
	"context"
)


// SSNTraceActivity is your custom Activity Definition.
func SSNTraceActivity(ctx context.Context, param string) (*string, error) {
	// This is where a call to another service is made
	// Here we are pretending that the service that does SSNTrace returned "pass"
	result := "pass"
	return &result, nil
}
```

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/ssntraceactivity_dacx.go. -->

The first parameter of an Activity Definition is `context.Context`.
This parameter is optional for an Activity Definition, though it is recommended, especially if the Activity is expected to use other Go SDK APIs.

An Activity Definition can support as many other custom parameters as needed.
However, all parameters must be serializable.
For example, parameters can’t be channels, functions, variadic, or unsafe pointers.

## Run a dev server Worker {#dev-server-worker}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/dev_server_worker/main_dacx.go. -->

To run a Worker Process with a local development server, define the following steps in code:

- Initialize a Temporal Client.
- Create a new Worker by passing the Client to creation call.
- Register the application's Workflow and Activity functions.
- Call run on the Worker.

In regards to organization, we recommend keeping Worker code separate from Workflow and Activity code.

:::copycode Copy this code!

This code is synced from a working and tested example application.
[View source](https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/dev_server_worker/main_dacx.go)

:::

```go
package main

import (
	"log"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"

	"documentation-samples-go/backgroundcheck_boilerplate"
)


func main() {
	// Initialize a Temporal Client
	// Specify the Namespace in the Client options
	clientOptions := client.Options{
		Namespace: "backgroundcheck_namespace",
	}
	temporalClient, err := client.Dial(clientOptions)
	if err != nil {
		log.Fatalln("Unable to create a Temporal Client", err)
	}
	defer temporalClient.Close()
	// Create a new Worker
	yourWorker := worker.New(temporalClient, "backgroundcheck-boilerplate-task-queue", worker.Options{})
	// Register Workflows
	yourWorker.RegisterWorkflow(backgroundcheck_boilerplate.BackgroundCheck)
	// Register Acivities
	yourWorker.RegisterActivity(backgroundcheck_boilerplate.SSNTraceActivity)
	// Start the the Worker Process
	err = yourWorker.Run(worker.InterruptCh())
	if err != nil {
		log.Fatalln("Unable to start the Worker Process", err)
	}
}
```

## Start Workflow using the CLI {#start-workflow}

**How to start the Workflow using the CLI?**

You can use the Temporal CLI to start a Workflow whether you are using a local development server, Temporal Cloud, or are in a Self-hosted environment.
However, you need to provide additional options to the command when operating with the Temporal Cloud or Self-hosted environments.

### Local dev Server

**How to start a Workflow with the Temporal CLI while using the local development server.**

Use the Temporal CLI `temporal workflow start` command to start your Workflow.

```shell
temporal workflow start --task-queue backgroundcheck-boilerplate-task-queue --type BackgroundCheck --input '"555-55-5555"' --namespace backgroundcheck_namespace
```

See the [temporal workflow start](/cli/workflow#start) command API reference for more details.

After starting the Workflow, we can now see it in the Temporal Platform.
We can use the Temporal CLI, or the Temporal Web UI to monitor the Workflow's progress.

#### List Workflows

Use the 'temporal workflow list` command to list all of the Workflows in the Namespace:

```shell
temporal workflow list --namespace backgroundcheck_namespace
```

#### View in Web UI

We can also use the Web UI to see all of the Workflows associated with the Namespace.

The local development server starts up the Web UI at [http://localhost:8233](http://localhost:8233).

When you visit for the first time, the Web UI direct you to [http://localhost:8233/namespaces/default/workflows](http://localhost:8233/namespaces/default/workflows).

Use the Namespace dropdown to select the project Namespace you created earlier.

<div class="tdiw"><div class="tditw"><p class="tdit">Web UI Namespace selection</p></div><div class="tdiiw"><img class="img_ev3q" src="/img/web-ui-namespace-selection.png" alt="Web UI Namespace selection" height="1402" width="3004" /></div></div>

You should now be at [http://localhost:8233/namespaces/backgroundcheck_namespace/workflows](http://localhost:8233/namespaces/backgroundcheck_namespace/workflows)

### Temporal Cloud

**How to start a Workflow with Temporal CLI when using Temporal Cloud.**

### Self-hosted

**How to start a Workflow with the Temporal CLI when using a Self-hosted Cluster.**

Use your Temporal CLI alias to run the `temporal workflow start` command and start your Workflow.

```shell
temporal_docker workflow start --task-queue backgroundcheck-boilerplate-task-queue --type BackgroundCheck --input '"555-55-5555"' --namespace backgroundcheck_namespace
```

#### List Workflows

Use your Temporal CLI alias to run the `temporal workflow list` command to list all of the Workflows in the Namespace:

```shell
temporal_docker workflow list --namespace backgroundcheck_namespace
```

#### View in the Web UI

When you visit for the first time, the Web UI direct you to [http://localhost:8233/namespaces/default/workflows](http://localhost:8080/namespaces/default/workflows).

Use the Namespace dropdown to select the project Namespace you created earlier.

You should now be at [http://localhost:8080/namespaces/backgroundcheck_namespace/workflows](http://localhost:8080/namespaces/backgroundcheck_namespace/workflows)

## Add a testing framework {#test-framework}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go. -->

**How to add a Testing Framework and Tests for the Workflow and Activity.**

Each Temporal SDK has a testing suite that can be used in conjunction with a typical language specific testing framework.
In the Temporal Go SDK, the `testsuite` package (https://pkg.go.dev/go.temporal.io/sdk/testsuite) provides a test environment in which the Workflow and Activity code may be run for test purposes.

:::copycode Copy this code!

This code is synced from a working and tested example application.
[View source](https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go)

:::

```go
package backgroundcheck_boilerplate

import (
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
)


// UnitTestSuite is a struct that wraps around the testing suites
type UnitTestSuite struct {
	// Add testify test suite package
	suite.Suite
	// Add the Temporal Go SDK Workflow test suite
	testsuite.WorkflowTestSuite
}
// ...
// Test_BackgroundCheckApplication runs the full set of tests in this application.
func Test_BackgroundCheckApplication(t *testing.T) {
	s := &UnitTestSuite{}
	suite.Run(t, s)
}
```

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go. -->

In this example, we use a custom struct that absorbs both the testing functionality from testify (https://pkg.go.dev/github.com/stretchr/testify/suite) via `suite.Suite` and the testing functionality from the Temporal test framework via `testsuite.WorkflowTestSuite`.
Next we create a regular test function recognized by the `go test` command, and pass an instance of the struct to `suite.Run`.

### Add Workflow function tests {#test-workflow-code}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go. -->

We can test Workflow code for the following conditions:

- Workflow status. For example, did the Workflow reach a completed status?
- Workflow returned an error. Did the Workflow function return an error?
- Error when checking for a result of a Workflow. Is there an error in getting the result returned by the Workflow.
- Workflow return value. If the Workflow did return something other than an error, is it what you expected it to be?

We can also perform a Workflow Replay test, and we'll provide detailed coverage of this topic in another section.

:::copycode Copy this code!

This code is synced from a working and tested example application.
[View source](https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go)

:::

```go
const ssn string = "555-55-5555"

// Test_BackgroundCheckWorkflow tests the BackgroundCheck Workflow function
func (s *UnitTestSuite) Test_BackgroundCheckWorkflow() {
	// Initialize a Temporal Go SDK Workflow test environment.
	// The best practice is to create a new environment for each Workflow test.
	// Doing so ensures that each test runs in its own isolated sandbox.
	env := s.NewTestWorkflowEnvironment()
	// Mock the Activity Execution for the Workflow
	ssnTraceResult := "pass"
	env.OnActivity(SSNTraceActivity, mock.Anything, ssn).Return(&ssnTraceResult, nil)
	// Run the Workflow in the test environment
	env.ExecuteWorkflow(BackgroundCheck, ssn)
	// Check that the Workflow reach a completed status
	s.True(env.IsWorkflowCompleted())
	// Check whether the Workflow returned an error
	s.NoError(env.GetWorkflowError())
	// Check that no error is returned while getting the result
	// And check for the expected value of the Workflow result
	var result string
	s.NoError(env.GetWorkflowResult(&result))
	s.Equal(result, ssnTraceResult)
}
```

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go. -->

Calling `env.ExecuteWorkflow(...)` executes the Workflow logic and any invoked Activities inside the test process.
The first parameter of `env.ExecuteWorkflow(...)` contains a reference to Workflow function and any parameters that the Workflow needs.

The call to `env.OnActivity` is important, because if this call is not made to "mock" the execution or another function is used to replace it, the test environment will execute the actual Activity code including any calls to outside services.

After executing the Workflow in the above example, we assert that the Workflow ran through completion via the call to `env.IsWorkflowComplete()`.
We also assert that no errors were returned by asserting on the return value of `env.GetWorkflowError()`.

If our Workflow returned a value, we could have retrieved that value via a call to `s.env.GetWorkflowResult(&value)` and had additional asserts on that value.

### Add Activity function tests {#test-activity-code}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go. -->

We can test Activity code for the following conditions:

- Error when invoking the Activity Execution.
- Error when checking for the result of the Activity Execution.
- Activity return values. Check to ensure the return value is expected.

:::copycode Copy this code!

This code is synced from a working and tested example application.
[View source](https://github.com/temporalio/documentation-samples-go/blob/backgroundcheckboilerplate/backgroundcheck_boilerplate/backgroundcheckboilerplate_dacx_test.go)

:::

```go
// Test_SSNTraceActivity tests the SSNTraceActivity function
func (s *UnitTestSuite) Test_SSNTraceActivity() {
	// Create a test environment
	env := s.NewTestActivityEnvironment()
	// Register Activity with the enviroment
	env.RegisterActivity(SSNTraceActivity)
	// Run the Activity in the test enviroment
	future, err := env.ExecuteActivity(SSNTraceActivity, ssn)
	// Check there was no error on the call to execute the Activity
	s.NoError(err)
	// Check  that there was no error returned from the Activity
	var result string
	s.NoError(future.Get(&result))
	// Check for the expected return value.
	s.Equal("pass", result)
}
```

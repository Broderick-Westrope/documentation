---
id: versioning
title: Versioning
sidebar_label: Versioning
sidebar_position: 6
description: This guide provides a comprehensive overview of Versioning.
slug: /versioning
toc_max_heading_level: 4
tags:
- explanation
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide provides a comprehensive overview of Versioning.

<!-- What is Versioning -->

Versioning is a process allowing for the management and updating of Workflow code or Workflow Definitions without causing non-deterministic behavior in existing Workflows or Tasks.
Workflow History contains the Execution History of a Workflow, including its Events, Tasks, Signals, and other information.
When a Workflow Definition changes in an incompatible way, the new Workflow code can't be used to process the existing Workflow History, as the existing Workflow History and the new Workflow code have taken different code paths.
Versioning allows Workflow to continue running on the old Workflow code, while new Workflows can start new code. This prevents Workflow Histories incompatibility issues.
Using Versioning, you can deploy changes to your Workflows, as they evolve, without disrupting existing executions.

<!-- What is Workflow Signature Compatibility -->

## What is Workflow Signature Compatibility?

The Workflow Signature refers to the input and output types of the Workflow Definition.
If you change the signature of a Workflow in an incompatible way, existing Workflow Executions may fail or behave incorrectly when resumed.
With Versioning, you can deploy a new Workflow version with a changed signature while existing executions continue unaffected on the old version.

<!-- What is Activity Signature Compatibility -->

## What is Activity Signature Compatibility?

Activities are re-usable units of work called by a Workflow. They have input and output signatures, like Workflows.
If you change an Activity Signature, existing Workflows may fail when calling the Activity.
With Versioning, older Workflows can continue calling the previous version of the Activity, while new Workflows use the new Activity version.

<!-- Table of contents -->

In the context of Temporal, there are different methods of Versioning:

- [Worker Versioning](#worker-versioning)
- [Patching](#patching)
- [Workflow Type Versioning](#workflow-type-versioning)

Each of these methods has its advantages and disadvantages and is suited for different use cases.

## Worker Versioning

Worker Versioning simplifies the deployment process of changes to Workflow Definitions by assigning a Build ID to the code that defines a Worker.

In the context of deploying changes to Workflow Definitions in a distributed system, the Worker Versioning strategy has a number of advantages and disadvantages:

### Advantages of Worker Versioning

Worker Versioning is valuable in several respects:

- **Safety against non-deterministic changes**: By providing a way to manage non-deterministic changes, Worker Versioning makes it less likely that Workers will attempt to process Workflow Tasks and Activity Tasks that they can't successfully handle.

- **Greater flexibility**: You can make compatible changes to open Workflows by adding a new version to an existing Version Set and defining it as _compatible_ with an existing version.

- **Smooth transition**: Allows for a smooth transition between different versions of Workers. New Workers execute new Workflow Executions, while old Workers with an appropriate version process old Workflow Executions.

- **Controlled decommissioning of old Workers**: Worker Versioning strategy allows for controlled decommissioning of old Workers as they can be phased out after all Workflows using their version are closed.

- **Integrated with Temporal's tooling**: Worker Versioning is managed through Temporal's CLI and SDKs, which makes it easier to integrate into your Workflows.

### Disadvantages of Worker Versioning

- **Long-lived Workflows**: While Worker Versioning works well with short-lived Workflows, it could be more challenging to implement with longer-lived Workflows. You might need to run multiple Worker versions simultaneously while open Workflows complete and are limited by the constraints of Worker Version Sets.

- **Increased operational overhead**: There could be increased operational overhead in managing different versions of Workers and ensuring compatibility, particularly in larger systems with many Workers.

### What is a Build ID?

A Build ID is any string that you associate with a version of a Workflow. As a user-generated string, it's used to track, manage, and reference different stages or versions of the Workflow.

In the context of a Workflow with Version Sets, a Build ID can be assigned as the default for a Version Set or as the overall default for the entire Workflow.

A Build ID can contain a maximum of 255 characters.

#### What is a default Build ID?

A Default Build ID is the specific Build ID that a Worker refers to when executing Tasks.
While this is typically the most recent Build ID, you can manually specify a different Build ID as the default when registering the Workflow with a Worker.
This option is beneficial for situations where you prefer an older Build ID to be the default rather than the latest one.
A unique Default Build ID can be assigned to both the Task Queue and each individual Compatible Version Set.

If you have one Build ID, it's known as the Default Build ID.

### What is a Version Set?

A Version Set groups multiple Build IDs for compatibility purposes within a Workflow.
Each Version Set contains a designated Default Build ID, and the entire Workflow has one overall Default Build ID.

#### What is a Compatible Version Set?

A Compatible Version Set is a user-defined collection of Build IDs that indicates which versions of Workflow and Activity code, data converters, and other task handling logic are mutually compatible.
Each Compatible Version Set contains Build IDs representing full Worker builds that are able to interoperate successfully.
This includes:

- Workflows
- Activities
- Data Converters
- Interceptors (if mutating any of the above)

Any changes to these components that impact compatibility must result in a new Build ID.

Each Compatible Version Set has a Default Build ID used to handle new Workflow executions and Activity tasks. Existing executions continue unaffected on their original Version Set.

This allows different versions of Workflows and Activities to co-exist, preventing compatibility issues on Workflows, Activities, and Workflow Hiistory processing. The Version Sets enable independent evolution of code.
Each Compatible Version Set has a Default Build ID.

A Task Queue has a default maximum of 10 Compatible Version Sets and a maximum of 100 Build IDs for a single Task Queue across all Compatible Version Sets.

You can visualize Compatible Version Sets as a list of lists, where each inner list represents a branch of compatible versions, where each inner list contains a set of compatible versions that can evolve independently. The lists allow simultaneous support for multiple version branches:

```yaml
Version Sets = [
  [Version 1.0, Version 1.1, Version 1.2],
  [Version 2.0, Version 2.1],
  [Version 3.0]
]
```

Each inner list is a set of Compatible Versions (for example, `1.x` versions in the first list).
Versions within the same inner list can process each other's Workflows and Tasks.
Versions from different inner lists are incompatible (or example, `1.x` vs`2.x`).
Each list represents the evolution of a particular version branch.
One version in each inner list is marked as the _default_.
New Workflows and Tasks are assigned to the default version for that list.

## Patching

Patching allows for the update of Workflow Definitions without breaking currently running Workflows.

Patching, is a set of steps or a technique used to manage changes or upgrades to your Workflow’s logic. Because Workflows can run for weeks, months, or years, you may want to change your Workflow code over time with changes that aren't backwards compatible.

Take the example of needing to modify some business logic that oversees the shipment of an item. Terminating all Workflows midway through delivery would not be a desirable approach. Instead, you would use patching to update your Workflow code.

:::note

In the [Go](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetVersion) and [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#getVersion(java.lang.String,int,int)) SDKs, Patching is referred to as `GetVersion`.

:::

### What is Patching

Patching allows you to update your Workflow code without terminating any running Workflows and retaining compatibility with your Workflow Event History, as a way to manage changes or upgrades to your Workflow’s logic.

### Advantages of Patching

Patching is valuable in several respects:

- **Quick Migration**: Patching allows you to change the yet-to-be-executed behavior of currently open Workflows while remaining compatible with existing Histories. This is because behavior of new Workflows always takes the _newest_ code path.

### Disadvantages of Patching

Patching has several drawbacks:

- **Conceptually complex**: While the code to write a patch is simple, the conceptual nature of patching is a cognitive burden of needing to understand how both the _old_ and _new_ code paths work.
- **Increased maintenance**: As your Workflow code paths start to branch, tracking the state of each branch becomes more complex. This is especially true if you need to patch a Workflow that has already branched. For example, Entity Workflows or indefinitely running Workflows complicate the patching process when you start to patch a Workflow that has already branched.

## Workflow Type Versioning

Workflow Type versioning is a technique that involves creating a new Workflow Type for every iteration or version of your Workflow. This strategy represents the most basic form of Workflow Versioning.

### What is Workflow Type Versioning?

In essence, Workflow Type versioning is the process of delineating different versions of your Workflow by associating them with distinct Workflow Types. For instance, when you change a Workflow code path, you update the Workflow Type as the next iteration in a sequence of Workflow Types: `workflow-v1`, `workflow-v2`, `workflow-v3`.

This approach offers a clear and straightforward way of distinguishing between various versions of your Workflow.

### Implement Workflow Type Versioning

To implement Workflow Type versioning, you need to create a new Workflow Type each time you intend to deploy an updated version of your Workflow. For instance, upon deploying `workflow-v1`, if you need to make changes, you would create a new Workflow Type and designate it as `workflow-v2`. The process continues in the same vein for all subsequent versions, such as `workflow-v3`, `workflow-v4`, and so forth.
While this approach is simple, it does require you to manually update all starters to use the latest Workflow Type. Additionally, you need to keep track of all Workflow Types and their corresponding versions.

### Advantages of Workflow Type Versioning

Workflow Type versioning is valuable in several respects:

- **Simplicity:** Workflow Type versioning provides a straightforward way to version your Workflows, making it an excellent choice for uncomplicated or small-scale projects.
- **Single Worker Fleet:** With this approach, you're not required to manage separate Worker fleets for each version of your Workflow, potentially minimizing infrastructure complexity and cost.

### Disadvantages of Workflow Type Versioning

Workflow Type versioning has several drawbacks, including:

- **Version Tracking:** All starters need to be informed about each new Workflow Type and its corresponding version, which might introduce communication overhead and room for error.
- **Code duplication**: This approach can lead to code duplication, as you need to create a new Workflow Type for each version of your Workflow. This can be especially problematic if you need to make a change to a Workflow that has already branched.

## Conclusion

Each Versioning strategy has its advantages and disadvantages. The best approach for your use case depends on your specific requirements and constraints.

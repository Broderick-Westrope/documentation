---
id: versioning
title: Versioning
sidebar_label: Versioning
sidebar_position: 6
description: This guide provides a comprehensive overview of Versioning.
slug: /versioning
toc_max_heading_level: 4
tags:
- explanation
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide provides a comprehensive overview of Versioning.

Versioning is a process that allows for the management and updating of Workflow code or Workflow Definitions without causing non-deterministic behavior in existing Workflows or Tasks.

In the context of Temporal, there are different methods of Versioning:

- [Worker Versioning](#worker-versioning)
- [Task Queue-based Versioning](#task-queue-versioning)
- [Patching](#patching)
- [Workflow Type Versioning](#workflow-type-versioning)

Each of these methods has its advantages and disadvantages and is suited for different use cases.

## Worker Versioning

Worker Versioning simplifies the deployment process of changes to Workflow Definitions by assigning a Build ID to the code that defines a Worker.

In the context of deploying changes to Workflow Definitions in a distributed system like Temporal, the Worker Versioning strategy has a number of advantages and disadvantages:

### Advantages of Worker Versioning

Worker Versioning is valuable in several respects:

- **Safety against non-deterministic changes**: By providing a way to manage non-deterministic changes, Worker Versioning makes it less likely that Workers will attempt to process Workflow Tasks and Activity Tasks that they can't successfully handle.

- **Greater flexibility**: You can make compatible changes to open Workflows by adding a new version to an existing Version Set and defining it as _compatible_ with an existing version.

- **Smooth transition**: Allows for a smooth transition between different versions of Workers. New Workers execute new Workflow Executions, while old Workers with an appropriate version process old Workflow Executions.

- **Controlled decommissioning of old Workers**: Worker Versioning strategy allows for controlled decommissioning of old Workers as they can be phased out after all Workflows using their version are closed.

- **Integrated with Temporal's tooling**: Worker Versioning is managed through Temporal's CLI and SDKs, which makes it easier to integrate into your Workflows.

### Disadvantages of Worker Versioning

- **Long-lived Workflows**: While Worker Versioning works well with short-lived Workflows, it could be more challenging to implement with longer-lived Workflows. You might need to run multiple Worker versions simultaneously while open Workflows complete and are limited by the constraints of Worker Version Sets.

- **Increased operational overhead**: There could be increased operational overhead in managing different versions of Workers and ensuring compatibility, particularly in larger systems with many Workers.

### What is a Build ID?

A Build ID is any string that you associate with a version of a Workflow. As a user-generated string, it's used to track, manage, and reference different stages or versions of the Workflow.

In the context of a Workflow with Version Sets, a Build ID can be assigned as the default for a Version Set or as the overall default for the entire Workflow.

A Build ID can contain a maximum of 255 characters.

#### What is a default Build ID?

A Default Build ID is the specific Build ID that a Worker refers to when executing Tasks.
While this is typically the most recent Build ID, you can manually specify a different Build ID as the default when registering the Workflow with a Worker.
This option is beneficial for situations where you prefer an older Build ID to be the default rather than the latest one.
A unique Default Build ID can be assigned to both the Task Queue and each individual Compatible Version Set.

If you have one Build ID, it's known as the Default Build ID.

### What is a Version Set?

A Version Set groups multiple Build IDs for compatibility, management, and display purposes within a Workflow.
Each Version Set contains a designated Default Build ID, and the entire Workflow has one overall Default Build ID.

#### What is a Compatible Version Set?

A Compatible Version Set is a user-defined collection of Build IDs that indicates which versions of the Workflow code are mutually compatible.
Each Compatible Version Set has a Default Build ID.

A Task Queue has a default maximum of 10 Compatible Version Sets and a maximum of 100 Build IDs for a single Task Queue across all Compatible Version Sets.

You can visualize Compatible Version Sets as a tree-like structure, where a branch represents the progressive evolution of each build. Each branch in the tree is a series of versions that are compatible with each other, but not necessarily with versions in other branches.

For example, Build ID of `1.0` might start a new branch and therefore isn't compatible with Build ID of `0.4` from an earlier branch. However, Build ID of `1.1` is compatible with Build ID of `1.0` because it's a newer version of the same branch.

## Task Queue-based Versioning

While Task Queue-based Versioning is available to use, it's recommended to use the [Worker Versioning](#worker-versioning) approach instead, as it simplifies the process of versioning your Task Queues.

Task Queue-based Versioning is the process of creating a new Task Queue for each version of your Workflow, and then modify the Task Queue the Client points to.

Workers pull from Task Queues, and because of that you start Workflows on Task Queues, and each Task Queues have a unique identifier.

Rather than creating a new Workflow Type for each version of your Workflow, you can create a new Task Queue for each version of your Workflow.

This approach is similar to Workflow Type versioning, but instead of creating a new Workflow Type for each version of your Workflow, you create a new Task Queue for each version of your Workflow.

This helps maintain clean libraries without branching logic.

### Advantages of Task Queue-based Versioning

Task Queue-based Versioning is valuable in several respects:

- **Conceptually easy**: Task Queues are similar to Workflow Type versioning, but with Task Queues, so you don't need to manually update all starters to use the latest Workflow Type.
- **Easy maintenance**: In comparison to Patching, Task Queue-based Versioning requires less maintenance because you don't need to track which Workflows are running on which version of the Workflow Type.

### Disadvantages of Task Queue-based Versioning

Task Queue Versioning has several disadvantages:

- **Operationally complex**: To run multiple versions of a Task Queue, you need to keep old Workers alive and change which Task Queue Clients point to. This can result in a number of sets of old Workers, which operationally can be complex to manage.
- **Bug fixes**: This approach can't be used to fix a bug in a currently running or open Workflow. Because the Workflow is already running, you are unable to change the Task Queue it's running on, and thus you can't make changes or fixes to the Workflow.

## Patching

Patching allows for the update of Workflow Definitions without affecting currently running Workflows.

Patching, is a set of steps or a technique used to manage changes or upgrades to your Workflow’s logic. Because Workflows can run for weeks, months, or years, you may want to change your Workflow code over time with changes that are not backwards compatible.

Take the example of needing to modify some business logic that oversees the shipment of an item. Terminating all Workflows midway through delivery would not be a desirable approach. Instead, you would use patching to update your Workflow code.

:::note

In the [Go](https://pkg.go.dev/go.temporal.io/sdk/workflow#GetVersion) and [Java](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/workflow/Workflow.html#getVersion(java.lang.String,int,int)) SDKs, Patching is referred to as `GetVersion`.

:::

### What is Patching

Patching allows you to update your Workflow code without terminating any running Workflows and retaining compatibility with your Workflow Event History, as a way to manage changes or upgrades to your Workflow’s logic.

### Advantages of Patching

Patching is valuable in several respects:

- **No Downtime**: Patching allows you to update your Workflow code without terminating any running Workflows.
- **Quick Migration**: Patching allows you to change the yet-to-be-executed behavior of currently open Workflows while remaining compatible with existing Histories. This is because behavior of new Workflows always takes the _newest_ code path.

### Disadvantages of Patching

Patching has several drawbacks:

- **Conceptually complex**: While the code to write a patch is simple, the conceptual nature of patching is a cognitive burden of needing to understand how both the _old_ and _new_ code paths work.
- **Increased maintenance**: As your Workflow code paths start to branch, tracking the state of each branch becomes more complex. This is especially true if you need to patch a Workflow that has already branched. For example, Entity Workflows or indefinitely running Workflows complicate the patching process when you start to patch a Workflow that has already branched.

## Workflow Type Versioning

Workflow Type versioning is a technique that involves creating a new Workflow Type for every iteration or version of your Workflow. This strategy represents the most basic form of Workflow Versioning.

### What is Workflow Type Versioning?

In essence, Workflow Type versioning is the process of delineating different versions of your Workflow by associating them with distinct Workflow Types. For instance, when you change a Workflow code path, you update the Workflow Type as the next iteration in a sequence of Workflow Types: `workflow-v1`, `workflow-v2`, `workflow-v3`.

This approach offers a clear and straightforward way of distinguishing between various versions of your Workflow.

### Implement Workflow Type Versioning

To implement Workflow Type versioning, you need to create a new Workflow Type each time you intend to deploy an updated version of your Workflow. For instance, upon deploying `workflow-v1`, if you need to make changes, you would create a new Workflow Type and designate it as `workflow-v2`. The process continues in the same vein for all subsequent versions, such as `workflow-v3`, `workflow-v4`, and so forth.
While this approach is simple, it does require you to manually update all starters to use the latest Workflow Type. Additionally, you need to keep track of all Workflow Types and their corresponding versions.

### Advantages of Workflow Type Versioning

Workflow Type versioning is valuable in several respects:

- **Simplicity:** Workflow Type versioning provides a straightforward way to version your Workflows, making it an excellent choice for uncomplicated or small-scale projects.
- **Single Worker Fleet:** With this approach, you're not required to manage separate Worker fleets for each version of your Workflow, potentially minimizing infrastructure complexity and cost.

### Disadvantages of Workflow Type Versioning

Workflow Type versioning has several drawbacks, including:

- **Version Tracking:** All starters need to be informed about each new Workflow Type and its corresponding version, which might introduce communication overhead and room for error.

## Conclusion

Each Versioning strategy has its advantages and disadvantages. The best approach for your use case depends on your specific requirements and constraints.
